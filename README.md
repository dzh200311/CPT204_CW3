# CPT204_CW3

### 使用说明
**run game.java, 输入dungeon.txt里的东西到控制台**

智能游戏角色已经被用于游戏行业，利用图算法的力量来导航复杂的虚拟环境，战略性地分析相互连接的节点和边，以优化它们的移动和决策过程。通过利用图遍历技术，如广度优先搜索（BFS）和深度优先搜索（DFS），这些角色可以高效地探索广阔的游戏世界，识别最佳路径，并预测对手的移动。
在这门课程中，你将运用你在第十讲中学到的图算法，开发一种有效的方法来追踪和拦截移动的对手，在一个名为Rogue的（简化版本的）2D游戏中。你还将创建一个可行的计划，以躲避来自该对手的拦截。

# 《Rogue》

游戏《Rogue》是由Michael Toy和Glen Wichman创作的，他们在1970年代后期尝试使用Ken Arnold的C库curses时设计了一个图形冒险游戏，如下所示。
1984年，卡内基梅隆大学的研究生开发了Rog-o-matic，一个自动化的《Rogue》玩家，成为了最高评级的玩家。Rog-o-matic的算法优先考虑避免与怪物遭遇，以便促进生命值的再生，提出了一个有趣的图搜索挑战，这启发了本课程。

## 游戏规则

《Rogue》游戏在一个N×N的网格上进行，代表地牢。两名玩家分别是一个游荡者和一个怪物。游荡者用字符@表示。怪物用大写字母A到Z表示。
怪物和游荡者轮流行动，怪物先行动。如果怪物拦截了游荡者（即占据了相同的位置），则怪物杀死游荡者，游戏结束。每个回合，玩家要么保持静止，要么移动到相邻的位置。
有三种类型的位置：

1. 房间，用 **.** 表示。
2. 走廊，用 **+** 表示。
3. 墙壁，用空格表示。
   移动规则如下：
- 如果玩家在房间位置，则可以朝着8个罗盘方向（北、东、南、西、北西、北东、南西、南东）之一移动到相邻的房间位置，或者朝着4个方向（北、东、南、西）之一移动到相邻的走廊位置。
- 如果玩家在走廊位置，则可以朝着4个方向（北、东、南、西）之一移动到相邻的房间或走廊位置。
- 墙壁是无法穿透的。

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f412bd2c-e902-4029-a089-4bcaf9757c53/6f5ee15e-8b36-4780-9999-2b3b14136f5e/Untitled.png)

在上面的第一个地牢中，游荡者可以通过向北移动并围绕走廊跑来无限期地避开怪物I。
在第二个地牢中，怪物A可以利用对角移动将游荡者困在角落里。

## 怪物的策略

怪物顽强，其唯一任务是追逐并拦截游荡者。怪物的一种自然策略是始终朝着游荡者前进一步。在底层图的层面上，这意味着怪物应该计算自己和游荡者之间的最短路径，并沿着这样的路径前进一步。这种策略不一定是最优的，因为可能存在并列情况，沿着一个最短路径前进一步可能比沿着另一个最短路径前进一步更好。

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f412bd2c-e902-4029-a089-4bcaf9757c53/76ec5168-13cf-4535-bc71-8523a5f7b33a/Untitled.png)

在上面的第一个地牢中，怪物B的唯一最优策略是向东北方向前进一步。向北或向东移动会让游荡者有机会疯狂地冲向相反的走廊入口。
在第二个地牢中，怪物C可以通过首先向东移动来保证拦截游荡者。
你的第一个任务是实现怪物的有效策略。为了实现怪物的策略，你可能需要考虑使用BFS算法。

## 游荡者的策略

游荡者的目标是尽可能避开怪物。一个简单的策略是移动到离怪物当前位置尽可能远的相邻位置。然而，该策略并不一定是最优的。
考虑以下两个地牢。

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f412bd2c-e902-4029-a089-4bcaf9757c53/89b43a59-cc42-4dcd-9f61-565b85b28814/Untitled.png)

很容易看出，这种策略可能会导致迅速且不必要的死亡，就像上面的第二个地牢中，游荡者可以通过向东南方向移动来避开怪物J。
另一个潜在的致命策略是走向最近的走廊。为了避开第一个地牢中的怪物F，游荡者必须朝着北边的走廊移动。
更有效的策略是识别游荡者可以在其中无限循环奔跑的一系列相邻走廊和房间位置，从而无限期地避开怪物。**这涉及识别和跟踪底层图中的某些循环**。当然，并不总是存在这样的循环，此时你的目标是尽可能地生存下去。为了实现游荡者的策略，你可能需要同时使用BFS和DFS算法。

# 实现与规范

在本节中，您将了解关于Rogue游戏实现和规范的预期细节，您需要遵循这些规范。

## 地牢文件输入格式

输入地牢由一个整数N组成，后跟N行，每行有2N个字符。例如：

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f412bd2c-e902-4029-a089-4bcaf9757c53/506211e2-7b80-4734-9eb1-2ace957724ac/Untitled.png)

房间是房间位置的一个连续的矩形块。房间之间可能不直接连接。也就是说，从一个房间到另一个房间的任何路径都将至少使用一个走廊位置。

将会有恰好一个怪物和一个游荡者，每个都将开始在某个房间位置。

您将获得18个地牢文件来测试您的代码。

您可以创建自己的地牢文件（在您的报告/视频中解释其新颖性！）。

在下面的评分子部分中，您需要展示您的游荡者和怪物在**至少5个非平凡的地牢**中的正确性和性能。

## Rogue游戏规范

我们将提供一些已经完成的游戏基础设施文件。有两个文件需要完成：Monster.java和Rogue.java，其中提供了一些骨架代码。

给定的文件只是为了快速启动：您应该修改文件，**使您的程序展示更多的面向对象编程原则**！

以下是Monster.java的接口：

```java
public Monster(Game g) // 创建一个玩游戏g的新怪物
public Site move() // 返回它移动到的相邻位置

```

类似的程序是Rogue.java：

```java
public Rogue(Game g) // 创建一个玩游戏g的新游荡者
public Site move() // 返回它移动到的相邻位置

```

move()方法应根据您创建的策略实现怪物/游荡者的移动。

Game.java从标准输入中读取地牢，并进行游戏和裁判工作。它有三个主要的接口函数，Rogue.java和Monster.java将需要这些函数。

```java
public Site getMonsterSite() // 返回怪物占据的位置
public Site getRogueSite() // 返回游荡者占据的位置
public Dungeon getDungeon() // 返回地牢

```

Dungeon.java表示一个N×N的地牢。

```java
public boolean isLegalMove(Site v, Site w) // 从位置v到位置w是否合法移动？
public boolean isCorridor(Site v) // 位置v是否是走廊位置？
public boolean isRoom(Site v) // 位置v是否是房间位置？
public int size() // 返回地牢的维度N

```

In.java是来自《算法》选修教材的库，用于从各种来源读取数据。您将需要为您的CW3程序创建自己的输入库。

Site.java是一个表示N×N地牢中位置的数据类型。

```java
public Site(int i, int j) // 为位置（i，j）创建新的Site
public int i() // 获取i坐标
public int j() // 获取j坐标
public int manhattan(Site w) // 返回从调用位置到w的曼哈顿距离
public boolean equals(Site w) // 调用位置是否等于w？

```

如果您有两个位于坐标**（i1，j1）和（i2，j2）的位置，则两个位置之间的曼哈顿距离是|i1 - i2| + |j1 - j2|。这代表了您需要移动的长度，假设您只能水平和垂直移动**。

您应该修改文件或创建其他Java文件，使您的最终程序展示更多的面向对象编程原则。最后，您必须仅使用CPT204覆盖的库（包括在Liang教材中）。违反这一点，使用CPT204未涵盖的库将导致自动得分为0。